#pragma version >=0.4.0;
#include "imports/stdlib.fc";

(int, int, slice) load_data() inline_ref {
  slice ds = get_data().begin_parse();
  return(
    ds~load_uint(32),
    ds~load_uint(256),
    ds~load_msg_addr()
  );
}

() store_data(int seqno, int public_key, slice owner_address) impure inline {
  set_data(
    begin_cell()
      .store_uint(seqno, 32)
      .store_uint(public_key, 256)
      .store_slice(owner_address)
    .end_cell()
  );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) {
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32);

  load_data();

  if (op == op::send_funds) {
    throw_unless(100, msg_value >= 2000000000);
    return();
  }

  throw(0xffff);
}

() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512);
  slice tmp_in_msg = in_msg;
  var hash = slice_hash(in_msg);

  (int seqno, int public_key, slice owner_address) = load_data();

  throw_unless(401, check_signature(hash, signature, public_key));

  in msg_seqno = tmp_in_msg;

  throw_unless(402, msg_seqno == seqno);

  accept_message();

  tmp_in_msg~tounch();
}